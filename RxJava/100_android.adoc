== RxAndroid

=== Using RxAndroid
RxAndroid is an extension to RxJava.
It providers a scheduler to run code in the main thread of Android.
It also provides the  the ability to create a scheduler that runs on a  Android Handler class. 
This the schedules, you can easily define an observable which does its work in a background thread, and post our results to the main thread.
This allows to replace `AsyncTask` implementations which RxJava.



To use RxJava in Android add the following dependency to your build.gradle file.

[source,gradle]
----
compile 'io.reactivex:rxjava:1.0.14'
compile 'io.reactivex:rxandroid:1.0.1'
----

Now you can use it. 
For example you can define a long running operation via the following observable.

[source,java]
----
final Observable serverDownloadObservable = Observable.create(new Observable.OnSubscribe() {
   @Override
   public void call(Subscriber subscriber) {
       subscriber.onNext(doSomeLongRunningStuff());
       subscriber.onCompleted();
   }
})
.subscribeOn(Schedulers.io())    #<1>
.observeOn(AndroidSchedulers.mainThread()); #<2>
----

<1>  Observable runs outside the main thread
<2>  Subscriber is called in the main thread

You can now subscribe to this observable. 
This triggers its execution and provide the subscribe with the required information.

For example, lets assume you assign this to a button.

[source,java]
----
myButton.setOnClickListener(new View.OnClickListener() {
   @Override
   public void onClick(final View view) {
       view.setEnabled(false); // disables the button until execution has finished
       operationObservable.subscribe(new Subscriber() {
           @Override
           public void onCompleted() {
               v.setEnabled(true); // enables it again
           }

           @Override
           public void onError(Throwable e) {}

           @Override
           public void onNext(String value) {
              updateTheUserInterface(); // this methods updates the ui
           }
       });
   }
});
----

As we are only interested in the final result, we could also use a `Single`.

[source,java]
----
Subscription subscription = Single.create(new Single.OnSubscribe() {
           @Override
           public void call(SingleSubscriber singleSubscriber) {
               String result = doSomeLongRunningStuff();
               singleSubscriber.onSuccess(value);
           }
       })
       .subscribeOn(Schedulers.io())
       .observeOn(AndroidSchedulers.mainThread())
       .subscribe(new Action1() {
           @Override
           public void call(String value) {
               // onSuccess
               updateTheUserInterface(); // this methods updates the ui
           }
       }, new Action1() {
           @Override
           public void call(Throwable throwable) {
               // handle onError
           }
       });
----


=== Unsubscribe to avoid memory leaks

`Observable.subscribe()` returns a `Subscription` object.
To prevent a possible memory leak, unsubscribe in to your observables in the`onStop()` method of the activity or fragment.
Check `Subscription.isUnsubscribed()` and if that is not true, call `Subscription.unsubscribe()`. U
You can add all your `Subscription` objects to an `CompositeSubscription` and all unsubscribed to all of them via the `CompositeSubscription.unsubscribe()` method.
 
 
=== Complete example code for replacing an AsyncTask

[source,java]
----
package com.vogella.android.rxjava.asynctask;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.Toast;

import rx.Observable;
import rx.Subscriber;
import rx.android.schedulers.AndroidSchedulers;
import rx.schedulers.Schedulers;

public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void onClick(final View view) {
        view.setEnabled(false);
        Observable<Void> voidObservable = Observable.create(new Observable.OnSubscribe<Void>() {
            @Override
            public void call(Subscriber<? super Void> subscriber) {
                longRunningOperation();
                subscriber.onNext(null);
                subscriber.onCompleted();

            }
        }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());
        voidObservable
                .subscribe(new Subscriber<Void>() {
                    @Override
                    public void onCompleted() {
                        Toast.makeText(MainActivity.this, "Finished", Toast.LENGTH_LONG).show();
                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(Void aVoid) {
                        view.setEnabled(true);
                        Toast.makeText(MainActivity.this, "Got a new value", Toast.LENGTH_LONG).show();
                    }
                })
        ;
    }

    public void longRunningOperation() {
        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
----


 