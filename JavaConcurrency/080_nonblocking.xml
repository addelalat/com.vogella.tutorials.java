<section id="nonblocking">
	<title>Nonblocking algorithms
	
		Java 5.0 provides supports for additional atomic operations. This
		allows to
		develop algorithm which are
		non-blocking algorithm, e.g.
		which do not require synchronization, but are based on low-level
		atomic hardware primitives
		such as compare-and-swap (CAS). A
		compare-and-swap operation check if the variable has a certain value
		and if it has
		this value it will perform this operation.
	
	 Non-blocking algorithms are typically faster than blocking
		algorithms, as the synchronization of threads
		appears on a much finer
		level (hardware).
	
	
		For example this created a non-blocking counter which always
		increases. This example is contained in the project called
		_de.vogella.concurrency.nonblocking.counter_
		.
	

	
		<programlisting>
			<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/nonblocking/Counter.java" />
		</programlisting>
	

	 And a test.

	
		<programlisting>
			<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/nonblocking/Test.java" />
		</programlisting>
	
	
		The interesting part is how the
		`incrementAndGet()`
		method
		is implemented. It
		uses a CAS operation.
	

	
		<programlisting>
			<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="./examples/nonblocking/increment.java" />
		</programlisting>
	

	
		The JDK itself makes more and more use of non-blocking algorithms
		to
		increase performance for every developer.
		Developing correct
		non-blocking algorithm is not a trivial task.
	

	
		For
		more information on
		non-blocking algorithm, e.g. examples for a
		non-blocking Stack and
		non-block LinkedList, please
		see
		<ulink url="http://www.ibm.com/developerworks/java/library/j-jtp04186/index.html">
			http://www.ibm.com/developerworks/java/library/j-jtp04186/index.html
		</ulink>
	

</section>